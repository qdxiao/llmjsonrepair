# llmjsonrepair

A Go library specifically designed to repair malformed JSON output from Large Language Models (LLMs)

## Introduction

`llmjsonrepair` is a powerful Go library designed to fix incomplete or malformed JSON data output by Large Language Models (LLMs). When JSON generated by LLMs cannot be parsed normally due to various reasons (such as output truncation, format errors, missing quotes, etc.), this library can intelligently repair these issues.

## Features

- üîß **Smart Repair**: Automatically fixes various JSON format errors
- üéØ **Context Aware**: Intelligently infers missing structures based on parsing context
- üöÄ **High Fault Tolerance**: Handles complex situations like deep nesting and mixed formats
- üì¶ **Easy to Use**: Provides clean API interfaces
- üîÑ **Multi-Object Support**: Supports processing continuous JSON object streams
- üß† **LLM Friendly**: Specifically designed for LLM output characteristics
- ‚ö° **High Performance**: State machine-based parser with excellent performance
- üõ°Ô∏è **Safe & Reliable**: Thoroughly tested with various edge cases

## Supported Error Types

- ‚úÖ Missing closing brackets/braces
- ‚úÖ Object keys without quotes
- ‚úÖ Unclosed strings
- ‚úÖ Deep nested structure errors
- ‚úÖ Messy quotes and escape characters
- ‚úÖ Truncated multi-JSON object streams
- ‚úÖ Missing separators (commas, colons)
- ‚úÖ Residual LLM reasoning text
- ‚úÖ Number format errors
- ‚úÖ Boolean and null value errors

## Installation

```bash
go get github.com/qdxiao/llmjsonrepair
```

## Quick Start

```go
package main

import (
    "fmt"
    "log"
    "github.com/qdxiao/llmjsonrepair/pkg"
)

func main() {
    // Example: Fix JSON with missing closing bracket
    malformedJSON := `{"name": "John", "age": 30, "skills": ["Go", "Python"`
    
    // Method 1: Repair and return formatted JSON string
    repairedJSON, err := pkg.Repair(malformedJSON)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("Repaired JSON:")
    fmt.Println(repairedJSON)
    
    // Method 2: Repair and return parsed data structure
    data, err := pkg.Loads(malformedJSON)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Parsed data: %+v\n", data)
}
```

## API Documentation

### `Repair(jsonStr string) (string, error)`

Repairs a JSON string and returns a formatted JSON string.

**Parameters:**
- `jsonStr`: The JSON string to be repaired

**Returns:**
- `string`: The repaired and formatted JSON string
- `error`: Error information (if repair fails)

**Example:**
```go
malformed := `{"name": "Alice", "age": 25`
repaired, err := pkg.Repair(malformed)
// Output: {"name": "Alice", "age": 25}
```

### `Loads(jsonStr string) (interface{}, error)`

Repairs a JSON string and returns the parsed data structure.

**Parameters:**
- `jsonStr`: The JSON string to be repaired

**Returns:**
- `interface{}`: The parsed data structure (`map[string]interface{}` or `[]interface{}`)
- `error`: Error information (if repair fails)

**Example:**
```go
malformed := `[1, 2, 3`
data, err := pkg.Loads(malformed)
// Returns: []interface{}{1, 2, 3}
```

### `NewParser(jsonStr string, opts ...Option) *parser`

Creates a new parser instance with custom options.

**Parameters:**
- `jsonStr`: The JSON string to be parsed
- `opts`: Optional configuration options

**Available Options:**
- `WithLogger(logger Logger)`: Set a custom logger

## Detailed Usage Examples

### 1. Basic Repair Examples

```go
// Missing closing bracket
malformed := `{"user": {"name": "John", "email": "john@example.com"`
repaired, _ := pkg.Repair(malformed)
fmt.Println(repaired)
// Output: {"user": {"name": "John", "email": "john@example.com"}}
```

### 2. Handling Unquoted Keys

```go
// Object keys without quotes
malformed := `{name: "Alice", age: 30, active: true}`
repaired, _ := pkg.Repair(malformed)
fmt.Println(repaired)
// Output: {"name": "Alice", "age": 30, "active": true}
```

### 3. Fixing String Closure Issues

```go
// Unclosed strings
malformed := `{"message": "Hello World, "status": "ok"}`
repaired, _ := pkg.Repair(malformed)
fmt.Println(repaired)
// Output: {"message": "Hello World", "status": "ok"}
```

### 4. Processing Multi-JSON Object Streams

```go
// Multiple JSON objects, second one truncated
malformed := `{"id": 1, "type": "start"}{"id": 2, "type": "update", "data": {"progress": 50`
data, _ := pkg.Loads(malformed)
fmt.Printf("%+v\n", data)
// Output: [map[id:1 type:start] map[id:2 type:update data:map[progress:50]]]
```

### 5. Skipping Non-JSON Text

```go
// JSON preceded by explanatory text
malformed := `Here is the response: {"result": "success", "code": 200`
repaired, _ := pkg.Repair(malformed)
fmt.Println(repaired)
// Output: {"result": "success", "code": 200}
```

## Advanced Usage

### Custom Logging

```go
import "log"

// Create custom logger
logger := log.New(os.Stdout, "[JSON-REPAIR] ", log.LstdFlags)

// Create parser with custom logger
parser := pkg.NewParser(malformedJSON, pkg.WithLogger(logger))
result, err := parser.Parse()
```

## Performance Characteristics

- **Memory Efficient**: Uses rune slices for Unicode handling, avoiding frequent string allocations
- **Fast Parsing**: Single-pass state machine-based parsing with O(n) time complexity
- **Fault Tolerance**: Intelligently skips invalid characters, maximizing data recovery

## Use Cases

- **AI Application Development**: Handle JSON output from ChatGPT, Claude, and other LLMs
- **API Integration**: Fix malformed JSON responses from third-party APIs
- **Data Processing**: Clean and repair JSON data in log files
- **Web Scraping**: Process incomplete JSON data extracted from web pages
- **Configuration Files**: Fix configuration file format errors caused by manual editing

## Test Cases

The project includes comprehensive test cases covering the following scenarios:

1. Simple repair: missing closing brackets
2. Deep nested structure errors
3. Messy quotes and escapes
4. Truncated JSON object streams
5. Malformed key-value pairs
6. Values as unclosed objects
7. Empty keys and missing values
8. Arrays with mixed unquoted strings and numbers
9. Residual LLM reasoning text

Run tests:
```bash
go test ./pkg -v
```

## FAQ

### Q: Can this library handle all types of JSON errors?
A: The library is optimized for common errors in LLM output and can handle most formatting issues. Extremely complex errors may require manual intervention.

### Q: Does the repaired JSON maintain original data types?
A: Yes, the library tries to preserve original data types (strings, numbers, booleans, null).

### Q: How is the performance?
A: Single-pass state machine-based parsing performs well for most use cases. Specific performance depends on input data complexity.

### Q: Does it support custom repair rules?
A: The current version provides general repair strategies. For specific repair rules, please submit feature requests via Issues.

## Contributing

We welcome contributions of all kinds!

### How to Contribute

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

### Reporting Issues

If you find bugs or have feature suggestions, please report them via GitHub Issues.

### Development Environment

- Go 1.18.0 or higher
- Go Modules recommended

## Changelog

### v1.0.0
- Initial release
- Basic JSON repair functionality
- Repair and Loads APIs
- Support for various common JSON format error repairs

## License

MIT License - see [LICENSE](LICENSE) file for details

## Acknowledgments

Thanks to all developers who have contributed to this project!

---

If this project helps you, please give us a ‚≠êÔ∏è!
